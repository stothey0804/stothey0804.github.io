---
title: \[javascript] 클래스
categories:
- Javascript
published: false
toc: true
toc_sticky: true
---

자바스크립트는 프로토타입 기반 언어이기 때문에 상속이 존재하지 않으며,
ES6에서는 클래스 문법이 추가되었으나, 일정 부분은 프로토타입을 활용하고 있기 때문에
ES5에서 클래스를 흉내내는 구현방식을 알아두는 것은 도움이 된다.

# 1. 자바스크립트의 클래스

```javascript
var Rectangle = function(width, height){    // 생성자
    this.width = width;
    this.height = height;
};
Rectangle.prototype.getArea = function(){   // (prototype) 메서드
    return this.width * this.height;
};
Rectangle.isRectangle = function(instance){ // static 메서드
    return instance instanceof Rectangle && instance.width > 0 && instance.height > 0;
};

var rect1 = new Rectangle(3, 4);
console.log(rect1.getArea());   // 12
console.log(rect1.isRectangle(rect1));  // Error
console.log(Rectangle.isRectangle(rect1));  // true
```

`rect1.getArea()`의 경우, `rect1.__proto__.getArea`에 접근하여 결과를 호출한다.
이처럼 인스턴스에서 직접 호출할 수 있는 메서드를 프로토타입 메서드라 한다.

`isRectangle()`메서드의 경우는 스태틱 메서드 이므로, 인스턴스에서 접근할 수 없으며 생성자 함수를 this로 해야 호출할 수 있는 것이다.

이 차이를 유념해야할 것이다.

# 2. 클래스 상속

## 2.1. 기본구현

프로토타입 파트에서 보았던 예시를 다시 보자

```javascript
var Grade = function(){
    var args = Array.prototype.slice.call(arguments);
    for(var i = 0; i < args.length; i++){
        this[i] = args[i];
    }
    this.length = args.length;
};
Grade.prototype = [];
var g = new Grade(100, 80);
```

자바스크립트에서 클래스 상속을 구현했다는 것은 프로토타입 체이닝을 잘 연결한 것으로 이해하면된다.

예제에서 문제는 `length` 프로퍼티가 configurable하다는 점과 `Grade.prototype`에 빈 배열을 참조시켰다는 점이다.
이 문제에 대해 살펴보자.

```javascript
...
g.push(90);
console.log(g); // Grade { 0: 100, 1: 80, 2: 90, length: 3 }

delete g.length;
g.push(70);
cosole.log(g);  // Grade { 0: 70, 1: 80, 2: 90, length: 1 }
```

length 프로퍼티를 삭제하는 코드 때문에 push값이 0번 인덱스에 들어가고 length가 1이 되는 현상이 발생한다.
내장객체인 배열 인스턴스의 length는 configurable 속성이 false라 삭제가 불가능하지만,
Grade는 일반 객체의 성질을 가지므로 삭제가 가능한 문제가 발생하는 것이다.




```javascript
```