---
title: \[javascript] ES6에서 바뀐 문법 정리
categories:
- Javascript
toc: true
toc_sticky: true
---

2015년을 기점으로 javascript에 큰 변화가 있었다. `ES2015 = ES6`이 그것이다.
실무에서는 대부분 최신 문법을 사용하여 작성하고 있다고하니 숙지하는게 좋다.



## 1. const, let

ES6+ 부터는 `var`를 `let`과 `const`가 대체한다. 
`var`는 함수 스코프를 가지는 반면 `const`와 `let`은 블록 스코프 `{}범위` 를 가지는 차이가 있다.
함수 스코프 대신 블록 스코프를 사용함으로써 호이스팅 문제가 해결된다.


```javascript
const a = 0;
a = 1;  // Uncaught TypeError

let b = 0;
b = 1; // 1

const c; // Uncaught Syntax Error
```

* const : 선언과 동시에 값을 할당하며, 수정할 수 없다. 상수 선언.

* let : 다른 값을 할당하는 상황에서 사용.


[참고] 자바스크립트를 사용할 때 한번 초기화 한 변수에 다른 값을 할당하는 경우가 적어서 다른 값을 할당해야하는 상황이 생겼을때 let을 사용한다.


## 2. 템플릿 문자열

백틱`\``으로 감싸면 문자열 안에 변수를 넣어 사용할 수 있다.


**ES6 이전 코드**
```javascript
var num1 = 1;
var num2 = 2;
var result = 3;
var string1 = num1 + ' 더하기 ' + num2 + ' 는 \'' + result + '\' 입니다.';
console.log(string1);    // 1 더하기 2는 '3' 입니다.

```

**ES6 이후 코드**
```javascript
const num1 = 1;
const num2 = 2;
const result = 3;
const string1 = `${num1} 더하기 ${num2}는 '${result}' 입니다.`;
console.log(string1);
```

## 3. 객체 리터럴

```javascript
var sayNode = function(){
    console.log('Node');
}
var es = 'ES';
var oldObject = {
    sayJS: function(){
        console.log('JS');
    },
    sayNode: sayNode,
};
oldObject[es + 6] = 'Fantastic';
oldObject.sayNode();    // Node
oldObject.sayJS();      // JS
console.log(oldObject.ES6); // Fantastic
```

```javascript
var newObject = {
    sayJS(){
        console.log('JS');
    },
    sayNode,
    [es + 6]: 'Fantastic',
};
newObject.sayNode();
newObject.sayJS();
console.log(newObject.ES6);
// 위와 동일하다.
```

코딩 시 편의를 위해 만들어진 문법으로

1. `sayJS`와 같은 객체의 메서드에 함수를 연결할 때 콜론과 function을 붙이지 않아도 된다.
2. `sayNode: sayNode` 처럼 속성명과 변수명이 동일한 경우 한번만 써도 되게 바뀌었다.
3. 객체의 속성명을 동적으로 생성할 때 이전에는 리터럴 바깥에서 지정해야했는데 ES2015+에서는 객체 리터럴 안에 선언해도 된다.


## 4. 화살표 함수

```javascript
// add1, 2, 3은 동일한 함수

function add1(x, y){
    return x + y;
}

const add2 = (x, y) => {
    return x + y;
}

const add3 = (x, y) => (x + y);

// not1, not2는 동일한 함수

function not1(x){
    return !x;
}

const not2 = x => !x;

```

`function`선언 대신 `=>`기호로 함수를 선언하며, 변수에 대입하면 나중에 재사용할 수 있다.
화살표 함수 내부에 return문만 있을 경우 return문을 생략하여 반환할 식을 바로 적을 수 있다.

기존 `function`과 다른 점은 `this` 바인딩 방식이며 

```javascript
// 기존방식
var relationship1 = {
    name: 'kim',
    friends: ['lee', 'park', 'han'],
    logFriends : function(){
        var that = this;    // relationship1을 가리키는 this를 저장
        this.friends.forEach(function(friend){
            console.log(that.name, friend);
        });
    },
};
relationship1.logFriends();

// 화살표함수
const relationship2 = {
    name: 'kim',
    friends: ['lee', 'park', 'han'],
    logFriends(){
        this.friends.forEach(friend => {
            console.log(this.name, friend);
        });
    },
}
relationship2.logFriends();
```

위와 같이 사용할떄 `relationship1`은 각자 다른 함수 스코프를 갖기때문에 변수 `that`에 따로 저장하여 간접적으로 접근하는 반면, `relationship2` 내의 화살표 함수는 상위 스코프의 `this`를 그대로 물려받을 수 있다.



## 5. 구조분해 할당



## 6. 클래스

## 7. 프로미스

## 8. async/await